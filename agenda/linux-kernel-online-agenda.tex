\documentclass[a4paper,12pt,obeyspaces,spaces,hyphens]{article}

\def \trainingtitle{Embedded Linux kernel and driver development training}
\def \trainingduration{On-line seminar, 7 sessions of 4 hours}
\def \agendalanguage{english}
\def \training{kernel}

\usepackage{agenda}

\begin{document}

\feshowtitle

\feagendasummaryitem{Title}{
  {\bf \trainingtitle{}}
}
\feagendasummaryitem{Training objectives}{
  \begin{itemize}
  \item Be able to configure, build and install the Linux kernel on an
    embedded system.
  \item Be able to understand the overall architecture of the Linux
    kernel, and how user-space applications interact with the Linux
    kernel.
  \item Be able to develop simple but complete Linux kernel device
    drivers, thanks to the development from scratch of two drivers for
    two different hardware devices, that illustrate all the major
    concepts of the course.
  \item Be able to navigate through the device drivers mechanisms of
    the Linux kernel: Device Tree, device model, bus infrastructures.
  \item Be able to develop device drivers that communicate with
    hardware devices.
  \item Be able to develop drivers that expose functionality of
    hardware devices to Linux user-space applications: character
    devices, kernel subsystems.
  \item Be able to use the major kernel mechanisms needed for device
    driver development: memory management, locking, interrupt
    handling, sleeping.
  \item Be able to debug Linux kernel issues, using a variety of
    debugging techniques and mechanisms.
  \end{itemize}
}
\feagendasummaryitem{Duration}{
  {\bf Height } half days - 32 hours (4 hours per half day), including breaks.
}
\onlinepedagogics{linux-kernel}
\feagendasummaryitem{Trainer}{
  One of the engineers listed on
  \newline \url{https://bootlin.com/training/trainers/}
}
\feagendasummaryitem{Language}{
  Oral lectures: English
  \newline Materials: English.
}
\feagendasummaryitem{Audience}{
  People developing devices using the Linux kernel
  \newline People supporting embedded Linux system developers.
}
\feagendasummaryitem{Prerequisites}{
  \begin{itemize}
    \prerequisiteclanguage
    \prerequisitecommandline
    \prerequisiteembeddedlinux
    \prerequisiteenglish
  \end{itemize}
}
\feagendasummaryitem{Required equipment}{
  \begin{itemize}
  \item Computer with the operating system of your choice, with the
    Google Chrome or Chromium browser for videoconferencing.
  \item Webcam and microphone (preferably from an audio headset)
  \item High speed access to the Internet
  \end{itemize}
}
\certificate{}
\disabilities{}

\feagendatwocolumn
{Hardware}
{
  The hardware platform used for the practical demos of this training
  session is the {\bf BeagleBone Black} board, which features:

  \begin{itemize}
  \item An ARM AM335x processor from Texas Instruments (Cortex-A8
    based), 3D acceleration, etc.
  \item 512 MB of RAM
  \item 2 GB of on-board eMMC storage
        \newline(4 GB in Rev C)
  \item USB host and device
  \item HDMI output
  \item 2 x 46 pins headers, to access UARTs, SPI buses, I2C buses
    and more.
  \end{itemize}
}
{}
{
  \begin{center}
    \includegraphics[height=5cm]{../slides/beagleboneblack-board/beagleboneblack.png}
  \end{center}
}

\feagendaonecolumn
{Demos}
{
  The practical demos of this training session use the following
  hardware peripherals to illustrate the development of Linux device
  drivers:

  \begin{itemize}
  \item A Wii Nunchuk, which is connected over the I2C bus to the
    BeagleBone Black board. Its driver will use the Linux {\em input}
    subsystem.
  \item An additional UART, which is memory-mapped, and will use the
    Linux {\em misc} subsystem.
  \end{itemize}

  While our explanations will be focused on specifically the Linux
  subsystems needed to implement these drivers, they will always be
  generic enough to convey the general design philosophy of the Linux
  kernel. The information learnt will therefore apply beyond just
  I2C, input or memory-mapped devices.
}


\section{Half day 1}

\feagendatwocolumn
{Lecture - Introduction to the Linux kernel}
{
  \begin{itemize}
  \item Kernel features
  \item Legal constraints with device drivers.
  \item Kernel user interface (/proc and /sys)
  \item User space device drivers
  \end{itemize}
}
{Lecture - Kernel sources}
{
  \begin{itemize}
  \item Specifics of Linux kernel development
  \item Coding standards
  \item Picking the right Linux kernel sources
  \item Tour of the Linux kernel sources
  \end{itemize}
}
\\
\feagendaonecolumn
{Demo - Kernel sources}
{
  \begin{itemize}
  \item Making searches in the Linux kernel sources: looking for C
    definitions, for definitions of kernel configuration parameters,
    and for other kinds of information.
  \item Using the UNIX command line and then kernel source code
    browsers.
  \item The release schedule and process: release candidates, stable
    releases, long-term support, etc.
  \end{itemize}
}

\section{Half day 2}

\feagendatwocolumn
{Lecture - Configuring, compiling and booting the Linux kernel}
{
  \begin{itemize}
  \item Kernel configuration.
  \item Native and cross compilation. Generated files.
  \item Booting the kernel. Kernel booting parameters.
  \item Mounting a root filesystem on NFS.
  \end{itemize}
}
{Demo - Kernel configuration, cross-compiling and booting on NFS}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Configuring, cross-compiling and booting a Linux kernel with
    NFS boot support.
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Linux kernel modules}
{
  \begin{itemize}
  \item Linux device drivers
  \item A simple module
  \item Programming constraints
  \item Loading, unloading modules
  \item Module dependencies
  \item Adding sources to the kernel tree
  \end{itemize}
}
{Demo - Writing modules}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Write a kernel module with several capabilities.
  \item Access kernel internals from your module.
  \item Set up the environment to compile it
  \end{itemize}
}

\feagendaonecolumn
{Lecture - The device tree language}
{
  \begin{itemize}
  \item Needs for description languages
  \item Syntax (nodes, subnodes, phandles/specifiers)
  \item Top nodes (cpu, memory, led, hos, etc)
  \item Generic properties
    (compatible, reg, irq, clk, dma, reset, gpio, power, power-domain, regulator)
    plus '-names' suffix, '-gpio' suffix
  \item Includes/overlays
  \item Bindings
  \end{itemize}
}

\section{Half day 3}

\feagendaonecolumn
{Demo - Device tree hacking}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Manage nodes: disable a controller
  \item Manage properties: give user GPIOs other functions
  \item Dive into the sysfs representation
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Understanding the boot flow}
{
  \begin{itemize}
  \item Arch initialization
  \item SoC identification/initialization
  \item Base initializations (clk, irq, memory)
  \item Drivers loading
  \item Device population
  \end{itemize}
}
{Demo - Display device tree parsing information}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Enable debug callsites to print the device tree parsing at boot time
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Linux device model}
{
  \begin{itemize}
  \item Understand how the kernel is designed to support device
    drivers
  \item The device model
  \item Binding devices and drivers
  \item Platform devices
  \item Parsing common properties
    [into regular C structures (compatible, reg, irq, clk)]
  \item Interface in user space: \code{/sys}
  \end{itemize}
}
{Demo - Linux device model for an I2C driver}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Implement a driver that registers as an I2C driver
  \item Modify the Device Tree to list an I2C device
  \item Get the driver called when the I2C device is enumerated at
    boot time
  \end{itemize}
}

\section{Half day 4}

\feagendaonecolumn
{Lecture - Introduction to the I2C API}
{
  \begin{itemize}
  \item The I2C subsystem of the kernel
  \item Details about the API provided to kernel drivers to interact
    with I2C devices
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Pin muxing}
{
  \begin{itemize}
  \item Understand the {\em pinctrl} framework of the kernel
  \item Understand how to configure the muxing of pins
  \end{itemize}
}
{Demo - Communicate with the Nunchuk over I2C}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Configure the pin muxing for the I2C bus used to communicate
    with the Nunchuk
  \item Extend the I2C driver started in the previous lab to
    communicate with the Nunchuk via I2C
  \end{itemize}
}

\feagendaonecolumn
{Lecture - Kernel frameworks}
{
  \begin{itemize}
  \item Block vs. character devices
  \item Interaction of user space applications with the kernel
  \item Details on character devices, \code{file_operations}, \code{ioctl()}, etc.
  \item Exchanging data to/from user space
  \item The principle of kernel frameworks
  \end{itemize}
}

\section{Half day 5}

\feagendatwocolumn
{Lecture - The input subsystem}
{
  \begin{itemize}
  \item Principle of the kernel {\em input} subsystem
  \item API offered to kernel drivers to expose input devices
    capabilities to user space applications
  \item User space API offered by the {\em input} subsystem
  \end{itemize}
}
{Demo - Expose the Nunchuk functionality to user space}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Extend the Nunchuk driver to expose the Nunchuk features to
    user space applications, as a {\em input} device.
  \item Test the operation of the Nunchuk using \code{evtest}
  \end{itemize}
}

\feagendaonecolumn
{Lecture - Memory management}
{
  \begin{itemize}
  \item Linux: memory management - Physical and virtual (kernel and user) address spaces.
  \item Linux memory management implementation.
  \item Allocating with \code{kmalloc()}.
  \item Allocating by pages.
  \item Allocating with \code{vmalloc()}.
  \end{itemize}
}

\feagendatwocolumn
{Lecture - I/O memory}
{
  \begin{itemize}
  \item I/O memory range registration.
  \item I/O memory access.
  \item Read / write memory barriers.
  \end{itemize}
}
{Demo - Minimal platform driver and access to I/O memory}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Implement a minimal platform driver
  \item Modify the Device Tree to instantiate the new serial port
    device.
  \item Reserve the I/O memory addresses used by the serial port.
  \item Try to access device registers.
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Clocking}
{
  \begin{itemize}
  \item Understanding the clock subsystem
  \item Clocks user API explanation
  \item Clock parenting
  \end{itemize}
}
{Demo - Clock handling and register accesses}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Enable the clocks (if possible)
  \item Enable runtime PM
  \item Access device registers
  \item Calculate prescalers using the clock rate
  \item Send characters on the serial port.
  \end{itemize}
}

\section{Half day 6}

\feagendatwocolumn
{Lecture - The misc kernel subsystem}
{
  \begin{itemize}
  \item What the {\em misc} kernel subsystem is useful for
  \item API of the {\em misc} kernel subsystem, both the kernel side
    and user space side
  \end{itemize}
}
{Demo - Output-only serial port driver}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Extend the driver started in the previous lab by registering
    it into the {\em misc} subsystem
  \item Implement serial port output functionality through the {\em
      misc} subsystem
  \item Test serial output from user space
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Processes, scheduling, sleeping and interrupts}
{
  \begin{itemize}
  \item Process management in the Linux kernel.
  \item The Linux kernel scheduler and how processes sleep.
  \item Interrupt handling in device drivers: interrupt handler
    registration and programming, scheduling deferred work.
  \end{itemize}
}
{Demo - Sleeping and handling interrupts in a device driver}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Adding read capability to the character driver developed
    earlier.
  \item Register an interrupt handler.
  \item Waiting for data to be available in the \code{read()} file operation.
  \item Waking up the code when data is available from the device.
  \end{itemize}
}

\section{Half day 7}

\feagendatwocolumn
{Lecture - DMA}
{
  \begin{itemize}
  \item The concept of Direct Memory Accesses
  \item DMA mappings
  \item dmaengine abstraction
  \end{itemize}
}
{Demo - Using DMA}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Transmit or receive bytes using DMA
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Alternative ways of interacting with a device}
{
  \begin{itemize}
  \item ioctl
  \item MMAP
  \end{itemize}
}
{Demo - Side communication channels}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Access the internal counter with an ioctl
  \item Expose the ring buffer to userspace with MMAP
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Locking}
{
  \begin{itemize}
  \item Issues with concurrent access to shared resources
  \item Locking primitives: mutexes, semaphores, spinlocks.
  \item Atomic operations.
  \item Typical locking issues.
  \item Using the lock validator to identify the sources of locking
    problems.
  \end{itemize}
}
{Demo - Locking}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Add locking to the current driver
  \end{itemize}
}

\section{Half day 8}
\feagendatwocolumn
{Lecture - Driver debugging techniques}
{
  \begin{itemize}
  \item Debugging with printing functions
  \item Perf
  \item Using Debugfs
  \item Using kgdb, a kernel debugger
  \item Analyzing a kernel oops
  \end{itemize}
}
{Demo - Investigating kernel faults}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Configuring kgdb to trigger on a Oops
  \item Studying a broken driver.
  \item Analyzing a kernel fault message and locating the problem in the
    source code.
  \end{itemize}
}

\feagendatwocolumn
{Lecture - Saving power}
{
  \begin{itemize}
  \item Power domains
  \item Runtime PM
  \item cpufreq, cpuidle
  \end{itemize}
}
{Demo - Use runtime PM}
{
  {\em Using the BeagleBone Black board}
  \begin{itemize}
  \item Get rid of the manual clock handling
  \item Trace runtime PM calls
  \end{itemize}
}

\feagendaonecolumn
{Lecture - Firmware interaction}
{
  \begin{itemize}
  \item Trusted Execution Environments (OPTEE)
  \item Secure services (SCMI, PSCI)
  \item Secure Monitor Calls (SMC)
  \end{itemize}
}

\feagendatwocolumn
{If time left}
{
  \begin{itemize}
  \item Final quiz
  \item Quiz notation
  \end{itemize}
}
{Questions and Answers}
{
  \begin{itemize}
  \item Questions and answers with the audience
  \end{itemize}
}

\end{document}
